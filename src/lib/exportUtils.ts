import * as THREE from "three";

interface ModelData {
  shapeType?: string;
  geometryParams?: {
    scale?: number;
    detailLevel?: number;
  };
  // Legacy support
  depthGrid?: number[][];
  scale?: number;
}

// =============== GEOMETRY GENERATORS (Shared with ModelViewer) ===============

function createHeartGeometry(detail: number = 48): THREE.BufferGeometry {
  const geometry = new THREE.BufferGeometry();
  const vertices: number[] = [];
  const normals: number[] = [];
  const indices: number[] = [];
  
  const latSegments = detail;
  const lonSegments = detail;
  
  for (let lat = 0; lat <= latSegments; lat++) {
    const v = lat / latSegments;
    const theta = v * Math.PI;
    
    for (let lon = 0; lon <= lonSegments; lon++) {
      const u = lon / lonSegments;
      const phi = u * 2 * Math.PI;
      
      const sinTheta = Math.sin(theta);
      const cosTheta = Math.cos(theta);
      const sinPhi = Math.sin(phi);
      const cosPhi = Math.cos(phi);
      
      let x = sinTheta * cosPhi;
      let y = cosTheta;
      let z = sinTheta * sinPhi;
      
      // Heart deformation
      if (y < -0.7) {
        const pointFactor = (-y - 0.7) / 0.3;
        x *= 1 - pointFactor * 0.8;
        z *= 1 - pointFactor * 0.8;
      }
      
      if (y > 0) {
        const lobeFactor = y * 0.5;
        const lobeOffset = Math.abs(Math.sin(phi)) * lobeFactor;
        x *= 1 + lobeOffset * 0.3;
        z *= 1 + lobeOffset * 0.3;
      }
      
      const scale = 1.8;
      x *= scale;
      y *= scale;
      z *= scale;
      
      vertices.push(x, y, z);
      
      const nx = x, ny = y, nz = z;
      const len = Math.sqrt(nx * nx + ny * ny + nz * nz) || 1;
      normals.push(nx / len, ny / len, nz / len);
    }
  }
  
  for (let lat = 0; lat < latSegments; lat++) {
    for (let lon = 0; lon < lonSegments; lon++) {
      const current = lat * (lonSegments + 1) + lon;
      const next = current + lonSegments + 1;
      indices.push(current, next, current + 1);
      indices.push(current + 1, next, next + 1);
    }
  }
  
  geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
  geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
  geometry.setIndex(indices);
  geometry.computeVertexNormals();
  
  return geometry;
}

function createOrganicGeometry(detail: number = 48): THREE.BufferGeometry {
  const geometry = new THREE.BufferGeometry();
  const vertices: number[] = [];
  const normals: number[] = [];
  const indices: number[] = [];
  
  const latSegments = detail;
  const lonSegments = detail;
  
  const noise = (x: number, y: number, z: number) => {
    return Math.sin(x * 3) * Math.cos(y * 4) * Math.sin(z * 3.5) * 0.15;
  };
  
  for (let lat = 0; lat <= latSegments; lat++) {
    const v = lat / latSegments;
    const theta = v * Math.PI;
    
    for (let lon = 0; lon <= lonSegments; lon++) {
      const u = lon / lonSegments;
      const phi = u * 2 * Math.PI;
      
      let x = Math.sin(theta) * Math.cos(phi);
      let y = Math.cos(theta);
      let z = Math.sin(theta) * Math.sin(phi);
      
      const n = noise(x * 5, y * 5, z * 5);
      const radius = 1.5 + n;
      
      x *= radius;
      y *= radius;
      z *= radius;
      
      vertices.push(x, y, z);
      
      const nx = x, ny = y, nz = z;
      const len = Math.sqrt(nx * nx + ny * ny + nz * nz) || 1;
      normals.push(nx / len, ny / len, nz / len);
    }
  }
  
  for (let lat = 0; lat < latSegments; lat++) {
    for (let lon = 0; lon < lonSegments; lon++) {
      const current = lat * (lonSegments + 1) + lon;
      const next = current + lonSegments + 1;
      indices.push(current, next, current + 1);
      indices.push(current + 1, next, next + 1);
    }
  }
  
  geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
  geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
  geometry.setIndex(indices);
  geometry.computeVertexNormals();
  
  return geometry;
}

function createGeometryFromModel(modelData: ModelData): THREE.BufferGeometry {
  const shapeType = modelData.shapeType || 'organic';
  const detail = modelData.geometryParams?.detailLevel || 48;
  
  switch (shapeType.toLowerCase()) {
    case 'heart':
      return createHeartGeometry(detail);
    default:
      return createOrganicGeometry(detail);
  }
}

export function exportToOBJ(modelData: ModelData): string {
  const geometry = createGeometryFromModel(modelData);
  const positions = geometry.attributes.position.array as Float32Array;
  const normals = geometry.attributes.normal?.array as Float32Array | undefined;
  const indices = geometry.index?.array;
  
  let obj = "# HoloLearn 3D Export - OBJ Format\n";
  obj += "# Generated by HoloLearn AI - True 3D Volumetric Model\n\n";
  obj += "o HoloLearn_Model\n\n";
  
  // Vertices
  for (let i = 0; i < positions.length; i += 3) {
    obj += `v ${positions[i].toFixed(6)} ${positions[i + 1].toFixed(6)} ${positions[i + 2].toFixed(6)}\n`;
  }
  obj += "\n";
  
  // Normals
  if (normals) {
    for (let i = 0; i < normals.length; i += 3) {
      obj += `vn ${normals[i].toFixed(6)} ${normals[i + 1].toFixed(6)} ${normals[i + 2].toFixed(6)}\n`;
    }
    obj += "\n";
  }
  
  // Faces
  if (indices) {
    for (let i = 0; i < indices.length; i += 3) {
      const a = indices[i] + 1;
      const b = indices[i + 1] + 1;
      const c = indices[i + 2] + 1;
      if (normals) {
        obj += `f ${a}//${a} ${b}//${b} ${c}//${c}\n`;
      } else {
        obj += `f ${a} ${b} ${c}\n`;
      }
    }
  }
  
  geometry.dispose();
  return obj;
}

export function exportToSTL(modelData: ModelData): ArrayBuffer {
  const geometry = createGeometryFromModel(modelData);
  const positions = geometry.attributes.position.array as Float32Array;
  const indices = geometry.index?.array;
  
  if (!indices) {
    throw new Error("Geometry has no indices");
  }
  
  const triangleCount = indices.length / 3;
  const headerLength = 80;
  const triangleDataLength = 4 * 12 + 2;
  const bufferLength = headerLength + 4 + triangleCount * triangleDataLength;
  
  const buffer = new ArrayBuffer(bufferLength);
  const dataView = new DataView(buffer);
  const header = "HoloLearn STL Export - True 3D Volumetric Model";
  
  for (let i = 0; i < headerLength; i++) {
    dataView.setUint8(i, i < header.length ? header.charCodeAt(i) : 0);
  }
  
  dataView.setUint32(headerLength, triangleCount, true);
  
  let offset = headerLength + 4;
  
  for (let i = 0; i < indices.length; i += 3) {
    const a = indices[i];
    const b = indices[i + 1];
    const c = indices[i + 2];
    
    const v1 = new THREE.Vector3(positions[a * 3], positions[a * 3 + 1], positions[a * 3 + 2]);
    const v2 = new THREE.Vector3(positions[b * 3], positions[b * 3 + 1], positions[b * 3 + 2]);
    const v3 = new THREE.Vector3(positions[c * 3], positions[c * 3 + 1], positions[c * 3 + 2]);
    
    const edge1 = new THREE.Vector3().subVectors(v2, v1);
    const edge2 = new THREE.Vector3().subVectors(v3, v1);
    const normal = new THREE.Vector3().crossVectors(edge1, edge2).normalize();
    
    dataView.setFloat32(offset, normal.x, true); offset += 4;
    dataView.setFloat32(offset, normal.y, true); offset += 4;
    dataView.setFloat32(offset, normal.z, true); offset += 4;
    
    dataView.setFloat32(offset, v1.x, true); offset += 4;
    dataView.setFloat32(offset, v1.y, true); offset += 4;
    dataView.setFloat32(offset, v1.z, true); offset += 4;
    
    dataView.setFloat32(offset, v2.x, true); offset += 4;
    dataView.setFloat32(offset, v2.y, true); offset += 4;
    dataView.setFloat32(offset, v2.z, true); offset += 4;
    
    dataView.setFloat32(offset, v3.x, true); offset += 4;
    dataView.setFloat32(offset, v3.y, true); offset += 4;
    dataView.setFloat32(offset, v3.z, true); offset += 4;
    
    dataView.setUint16(offset, 0, true); offset += 2;
  }
  
  geometry.dispose();
  return buffer;
}

export function exportToGLTF(modelData: ModelData): string {
  const geometry = createGeometryFromModel(modelData);
  const positions = geometry.attributes.position.array as Float32Array;
  const normals = geometry.attributes.normal?.array as Float32Array;
  const indices = geometry.index?.array;
  
  if (!indices) {
    throw new Error("Geometry has no indices");
  }
  
  const positionBuffer = btoa(String.fromCharCode(...new Uint8Array(positions.buffer)));
  const normalBuffer = normals ? btoa(String.fromCharCode(...new Uint8Array(normals.buffer))) : "";
  const indexBuffer = btoa(String.fromCharCode(...new Uint8Array(new Uint16Array(indices).buffer)));
  
  const gltf = {
    asset: {
      version: "2.0",
      generator: "HoloLearn 3D Export - True Volumetric"
    },
    scene: 0,
    scenes: [{ nodes: [0] }],
    nodes: [{ mesh: 0, name: "HoloLearn_Volumetric_Model" }],
    meshes: [{
      primitives: [{
        attributes: {
          POSITION: 0,
          ...(normals ? { NORMAL: 1 } : {})
        },
        indices: normals ? 2 : 1,
        material: 0
      }]
    }],
    materials: [{
      name: "HoloLearn_Material",
      pbrMetallicRoughness: {
        baseColorFactor: [0.91, 0.71, 0.71, 1],
        metallicFactor: 0.1,
        roughnessFactor: 0.5
      }
    }],
    accessors: [
      {
        bufferView: 0,
        componentType: 5126,
        count: positions.length / 3,
        type: "VEC3",
        max: [3, 3, 3],
        min: [-3, -3, -3]
      },
      ...(normals ? [{
        bufferView: 1,
        componentType: 5126,
        count: normals.length / 3,
        type: "VEC3"
      }] : []),
      {
        bufferView: normals ? 2 : 1,
        componentType: 5123,
        count: indices.length,
        type: "SCALAR"
      }
    ],
    bufferViews: [
      { buffer: 0, byteOffset: 0, byteLength: positions.byteLength },
      ...(normals ? [{ buffer: 1, byteOffset: 0, byteLength: normals.byteLength }] : []),
      { buffer: normals ? 2 : 1, byteOffset: 0, byteLength: indices.length * 2 }
    ],
    buffers: [
      { uri: `data:application/octet-stream;base64,${positionBuffer}`, byteLength: positions.byteLength },
      ...(normals ? [{ uri: `data:application/octet-stream;base64,${normalBuffer}`, byteLength: normals.byteLength }] : []),
      { uri: `data:application/octet-stream;base64,${indexBuffer}`, byteLength: indices.length * 2 }
    ]
  };
  
  geometry.dispose();
  return JSON.stringify(gltf, null, 2);
}

export function downloadFile(content: string | ArrayBuffer, filename: string, mimeType: string) {
  const blob = content instanceof ArrayBuffer 
    ? new Blob([content], { type: mimeType })
    : new Blob([content], { type: mimeType });
  
  const url = URL.createObjectURL(blob);
  const link = document.createElement("a");
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}
