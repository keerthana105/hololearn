import * as THREE from "three";

interface ModelData {
  depthGrid: number[][];
  scale?: number;
}

function createGeometryFromDepthGrid(depthGrid: number[][], scale: number = 1): THREE.BufferGeometry {
  const size = depthGrid.length;
  const geometry = new THREE.PlaneGeometry(4, 4, size - 1, size - 1);
  const positions = geometry.attributes.position.array as Float32Array;
  
  for (let i = 0; i < size; i++) {
    for (let j = 0; j < size; j++) {
      const vertexIndex = (i * size + j) * 3 + 2;
      const depth = depthGrid[i]?.[j] ?? 0.5;
      positions[vertexIndex] = (1 - depth) * 1.5 * scale;
    }
  }
  
  geometry.computeVertexNormals();
  return geometry;
}

export function exportToOBJ(modelData: ModelData): string {
  const geometry = createGeometryFromDepthGrid(modelData.depthGrid, modelData.scale);
  const positions = geometry.attributes.position.array as Float32Array;
  const normals = geometry.attributes.normal?.array as Float32Array | undefined;
  const indices = geometry.index?.array;
  
  let obj = "# HoloLearn 3D Export - OBJ Format\n";
  obj += "# Generated by HoloLearn AI\n\n";
  obj += "o HoloLearn_Model\n\n";
  
  // Vertices
  for (let i = 0; i < positions.length; i += 3) {
    obj += `v ${positions[i].toFixed(6)} ${positions[i + 1].toFixed(6)} ${positions[i + 2].toFixed(6)}\n`;
  }
  obj += "\n";
  
  // Normals
  if (normals) {
    for (let i = 0; i < normals.length; i += 3) {
      obj += `vn ${normals[i].toFixed(6)} ${normals[i + 1].toFixed(6)} ${normals[i + 2].toFixed(6)}\n`;
    }
    obj += "\n";
  }
  
  // Faces
  if (indices) {
    for (let i = 0; i < indices.length; i += 3) {
      const a = indices[i] + 1;
      const b = indices[i + 1] + 1;
      const c = indices[i + 2] + 1;
      if (normals) {
        obj += `f ${a}//${a} ${b}//${b} ${c}//${c}\n`;
      } else {
        obj += `f ${a} ${b} ${c}\n`;
      }
    }
  }
  
  geometry.dispose();
  return obj;
}

export function exportToSTL(modelData: ModelData): ArrayBuffer {
  const geometry = createGeometryFromDepthGrid(modelData.depthGrid, modelData.scale);
  const positions = geometry.attributes.position.array as Float32Array;
  const indices = geometry.index?.array;
  
  if (!indices) {
    throw new Error("Geometry has no indices");
  }
  
  const triangleCount = indices.length / 3;
  const headerLength = 80;
  const triangleDataLength = 4 * 12 + 2; // 12 floats + 2 bytes
  const bufferLength = headerLength + 4 + triangleCount * triangleDataLength;
  
  const buffer = new ArrayBuffer(bufferLength);
  const dataView = new DataView(buffer);
  const header = "HoloLearn STL Export - Binary Format";
  
  // Header
  for (let i = 0; i < headerLength; i++) {
    dataView.setUint8(i, i < header.length ? header.charCodeAt(i) : 0);
  }
  
  // Triangle count
  dataView.setUint32(headerLength, triangleCount, true);
  
  let offset = headerLength + 4;
  
  for (let i = 0; i < indices.length; i += 3) {
    const a = indices[i];
    const b = indices[i + 1];
    const c = indices[i + 2];
    
    // Get vertices
    const v1 = new THREE.Vector3(positions[a * 3], positions[a * 3 + 1], positions[a * 3 + 2]);
    const v2 = new THREE.Vector3(positions[b * 3], positions[b * 3 + 1], positions[b * 3 + 2]);
    const v3 = new THREE.Vector3(positions[c * 3], positions[c * 3 + 1], positions[c * 3 + 2]);
    
    // Calculate normal
    const edge1 = new THREE.Vector3().subVectors(v2, v1);
    const edge2 = new THREE.Vector3().subVectors(v3, v1);
    const normal = new THREE.Vector3().crossVectors(edge1, edge2).normalize();
    
    // Normal
    dataView.setFloat32(offset, normal.x, true); offset += 4;
    dataView.setFloat32(offset, normal.y, true); offset += 4;
    dataView.setFloat32(offset, normal.z, true); offset += 4;
    
    // Vertex 1
    dataView.setFloat32(offset, v1.x, true); offset += 4;
    dataView.setFloat32(offset, v1.y, true); offset += 4;
    dataView.setFloat32(offset, v1.z, true); offset += 4;
    
    // Vertex 2
    dataView.setFloat32(offset, v2.x, true); offset += 4;
    dataView.setFloat32(offset, v2.y, true); offset += 4;
    dataView.setFloat32(offset, v2.z, true); offset += 4;
    
    // Vertex 3
    dataView.setFloat32(offset, v3.x, true); offset += 4;
    dataView.setFloat32(offset, v3.y, true); offset += 4;
    dataView.setFloat32(offset, v3.z, true); offset += 4;
    
    // Attribute byte count
    dataView.setUint16(offset, 0, true); offset += 2;
  }
  
  geometry.dispose();
  return buffer;
}

export function exportToGLTF(modelData: ModelData): string {
  const geometry = createGeometryFromDepthGrid(modelData.depthGrid, modelData.scale);
  const positions = geometry.attributes.position.array as Float32Array;
  const normals = geometry.attributes.normal?.array as Float32Array;
  const indices = geometry.index?.array;
  
  if (!indices) {
    throw new Error("Geometry has no indices");
  }
  
  // Convert to base64
  const positionBuffer = btoa(String.fromCharCode(...new Uint8Array(positions.buffer)));
  const normalBuffer = normals ? btoa(String.fromCharCode(...new Uint8Array(normals.buffer))) : "";
  const indexBuffer = btoa(String.fromCharCode(...new Uint8Array(new Uint16Array(indices).buffer)));
  
  const gltf = {
    asset: {
      version: "2.0",
      generator: "HoloLearn 3D Export"
    },
    scene: 0,
    scenes: [{ nodes: [0] }],
    nodes: [{ mesh: 0, name: "HoloLearn_Model" }],
    meshes: [{
      primitives: [{
        attributes: {
          POSITION: 0,
          ...(normals ? { NORMAL: 1 } : {})
        },
        indices: normals ? 2 : 1,
        material: 0
      }]
    }],
    materials: [{
      name: "HoloLearn_Material",
      pbrMetallicRoughness: {
        baseColorFactor: [0, 0.83, 1, 1],
        metallicFactor: 0.3,
        roughnessFactor: 0.4
      }
    }],
    accessors: [
      {
        bufferView: 0,
        componentType: 5126,
        count: positions.length / 3,
        type: "VEC3",
        max: [2, 2, 2],
        min: [-2, -2, -2]
      },
      ...(normals ? [{
        bufferView: 1,
        componentType: 5126,
        count: normals.length / 3,
        type: "VEC3"
      }] : []),
      {
        bufferView: normals ? 2 : 1,
        componentType: 5123,
        count: indices.length,
        type: "SCALAR"
      }
    ],
    bufferViews: [
      { buffer: 0, byteOffset: 0, byteLength: positions.byteLength },
      ...(normals ? [{ buffer: 1, byteOffset: 0, byteLength: normals.byteLength }] : []),
      { buffer: normals ? 2 : 1, byteOffset: 0, byteLength: indices.length * 2 }
    ],
    buffers: [
      { uri: `data:application/octet-stream;base64,${positionBuffer}`, byteLength: positions.byteLength },
      ...(normals ? [{ uri: `data:application/octet-stream;base64,${normalBuffer}`, byteLength: normals.byteLength }] : []),
      { uri: `data:application/octet-stream;base64,${indexBuffer}`, byteLength: indices.length * 2 }
    ]
  };
  
  geometry.dispose();
  return JSON.stringify(gltf, null, 2);
}

export function downloadFile(content: string | ArrayBuffer, filename: string, mimeType: string) {
  const blob = content instanceof ArrayBuffer 
    ? new Blob([content], { type: mimeType })
    : new Blob([content], { type: mimeType });
  
  const url = URL.createObjectURL(blob);
  const link = document.createElement("a");
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}
